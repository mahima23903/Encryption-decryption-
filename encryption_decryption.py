# -*- coding: utf-8 -*-
"""encryption-decryption.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CPI78p8YFW_Xyq9IyDMc-IfqyNVcENBh
"""

!pip install PyCryptoDome

"""IMPORTING PANDAS TO WORK WITH DATA IN A DATAFRAME"""

import Crypto
import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

!unzip '/content/drive/MyDrive/archive (8).zip'

path = '/content/Banking Dataset Sample.xlsx'

df_ = pd.read_csv('/content/ML.csv') #reading file

# to acess and work with create a dataframe

df = pd.DataFrame(df_)

print(df)

df = df.drop(['date', 'typeoffraud','typeofaction','isfraud'], axis=1) #dropping unnecessary columns
 print(df)

df.describe() #describes about the data - mean 1st and 3rd quartile,etc..

df.dtypes

df['sourceid'] = df['sourceid'].astype(str)
df['destinationid'] = df['destinationid'].astype(str)
df['amountofmoney'] = df['amountofmoney'].astype(str)

df.dtypes

df.loc[1]

"""GETTING THE KEY AND PROCEEDING WITH ENCODING AND DECODING"""

from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2 # brute force protection
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad,unpad

simple_key = get_random_bytes(32)
print(simple_key)
'''Note- When the following snippet is executed we get a random set of bits every time which is unique from the previous execution.
We have already obtained the random bytes which are used as a key to encrypt the data.
Re- running the snippet may lead to error in the execution of the following functions. Thus if re-run, we will have to change the key value in the below functios.'''

pwd = 'unknown123'
encrypt_salt = b"B\x19EqX=\x1e\xde\xe3\x1c\x08\xda5\x7f\x8eP'\xa7\xe6\xfa\xdd\xc6\x82+4\x05\xf6\x04\x009r\x8f"

def Encrypt_(message):
  encrypt_salt = b"B\x19EqX=\x1e\xde\xe3\x1c\x08\xda5\x7f\x8eP'\xa7\xe6\xfa\xdd\xc6\x82+4\x05\xf6\x04\x009r\x8f"
  pwd = 'unknown123'
#generating keys for encryption
  keys = PBKDF2(pwd, encrypt_salt, dkLen=32)
  cipher = AES.new(keys, AES.MODE_CBC)
  cipher_data = cipher.encrypt(pad(message, AES.block_size)) #encryption
  with open ('encrypted_.bin', 'ab') as f:
    f.write(cipher.iv)
    f.write(cipher_data)
  return 'data stored'

def Decrypt_(bin_file):
  encrypt_salt = b"B\x19EqX=\x1e\xde\xe3\x1c\x08\xda5\x7f\x8eP'\xa7\xe6\xfa\xdd\xc6\x82+4\x05\xf6\x04\x009r\x8f"
  keys = PBKDF2(pwd , encrypt_salt, dkLen=32)
  with open(bin_file,'rb') as f:
    iv = f.read(16)
    decrypt_data = f.read()
  cipher = AES.new(keys, AES.MODE_CBC, iv=iv)
  original = unpad(cipher.decrypt(decrypt_data),AES.block_size)
  return original

# we are looping for first 100 rows of data from the data frame
# we can specify any number till the end of the data frame
for i in range(0,2340):
  string = str(df.loc[i])
  message = b'xyz'
  x_string = message.decode('utf-8')
  x_string_replaced = x_string.replace('xyz', string )
  x_replaced_bytes = x_string_replaced.encode('utf-8')
  Encrypt_(x_replaced_bytes)

Decrypt_('encrypted_.bin')

"""Storing key in the binary file for later access and security, Thus altering functions therefore making it usabe for any data-key pairs."""

#storing the key in a binary file
keys = PBKDF2(pwd, encrypt_salt, dkLen=32)
encrypt_salt = b'\x02e&/\xa2|\xd0\xbfx\xe99\xb8L\x10h\xde\x83\xbby\x8aXeL(JWc\x00J\xb3\xa6n'
pwd = 'unknown123'
with open('key.bin','ab') as fil:
  fil.write(keys)

def Encrypt_2(message,bin_file):
  with open(bin_file,'rb') as f:
    key = f.read()
  cipher = AES.new(keys, AES.MODE_CBC)
  cipher_data = cipher.encrypt(pad(message, AES.block_size)) #encryption
  with open ('encrypted_2.bin', 'ab') as f:
    f.write(cipher.iv)
    f.write(cipher_data)
  return 'data stored'

#The above written functions can be altered as follows
#this alows us to use the code for any combination of key and data values
#only if the key is known the data can be decrypted
def Decrypt_2(bin_file,bin_filekey):
  with open(bin_filekey,'rb') as f:
    key = f.read()
  with open(bin_file,'rb') as f:
    iv = f.read(16)
    decrypt_data = f.read()
  cipher = AES.new(key, AES.MODE_CBC, iv=iv)
  original = unpad(cipher.decrypt(decrypt_data),AES.block_size)
  return original

for i in range(0,2340):
  string = str(df.loc[i])
  message = b'xyz'
  x_string = message.decode('utf-8')
  x_string_replaced = x_string.replace('xyz', string )
  x_replaced_bytes = x_string_replaced.encode('utf-8')
  Encrypt_2(x_replaced_bytes,'key.bin')

#Now accessing the key from the binary file instead of having it in the function


Decrypt_2('encrypted_2.bin','key.bin')
#if wrong key is used, wrong data is retrived